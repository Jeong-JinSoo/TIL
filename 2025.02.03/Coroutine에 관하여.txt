Coroutine

코루틴은 Co(함께, 서로) + routine(규칙적 일의 순서, 작업의 집합) 2개가 합쳐진 단어
함께 동작하며 규칙이 있는 일의 순서를 뜻한다.

위키 피디아의 정의는 다음과 같다. 
"실행의 지연과 재개를 허용함으로써, 비선점적 멀티태스팅을 위한 서브 루틴을 일반화한 컴퓨터 프로그램 구성요소"

그렇다면 비 선점적 멀티 태스킹은 무엇인가?
- 비선점형 : 하나의 프로세스가 CPU를 할당 받으면 종료되기 전까지 다른 프로세스가 CPU를 강제로 차지할 수 없다.
- 선점형 : 하나의 프로세스가 다른 프로세스 대신에 프로세서(CPU)를 강제로 차지할 수 있다.

코루틴은 비선점형이므로 병행성은 제공하나 병렬성은 제공하지 않는다.
- 병행성(=동시성, Concurrency) : 논리적으로 병렬로 작업이 실행되는 것처럼 보이는 것
- 병렬성(Paralleism) : 물리적으로 병렬로 작업이 실행되는 것

선점형으로 비동기 처리시 몇가지 문제점이 발생한다.
1. 코드의 복잡성
	독립적인 쓰레드 안에서 각 루틴이 동작하기에 동시성을 제어하는 복잡한 코드가 필요하며 	이는 코드 흐름 파악을 어렵게 한다.
2. 비용
	무분별하게 쓰레드를 사용하면 Context switching 리소스 비용으로 프로그램 성능이 저하	된다.

  이런 문제를 해결하기 위해 다양한 방법이 나오는데, 코루틴은 이런 단점을 해결해 주는 언어적 지원 방법이며 비선점적 멀티태스킹을 사용하여 해결하고 있다.
  코루틴은 Context를 오버라이드 하며 실행된다. 따라서 하나의 쓰레드에서 여러 코루틴을 실행, 중단, 재개하는 상호작용을 통해 병행성을 갖기에 쓰레드와 메모리 사용이 줄어들고 개발자가 직접 작업을 스케줄링 할 수 있도록 한다.

다음으로 서브 루틴이란 무엇인가?
프로그램은 여러 루틴의 조합으로 진행되는데, 메인루틴과 서브 루틴으로 나뉜다.
- 메인 루틴 : 프로그램 전체의 개괄적인 동작으로 main 함수에 의해 수행되는 흐름
- 서브 루틴 : 반복적인 기능을 모은 동작으로 main 함수 내에서 실행되는 개별 함수의 흐름

서브 루틴은 메모리에 기능을 모아 놓고, 호출 시 저장된 메모리로 이동한 뒤 실행 후 반환문을 통해 원래 호출 위치로 돌아온다.(기존의 함수 동작 방식)

코루틴은 서브 루틴과 비슷하지만 큰 차이점이 있다.
서브 루틴은 단일 진입 지점에서 시작 후 단일 반환 지점에서 종료되는 것에 반해, 코루틴은 진입 후 반환문이 없더라고 임의 지점에서 실행 중 동작을 중단하고 이후 해당 지점에서 부터 실행을 재개한다. (진입과 반환이 여러개 일 수 있다.)

[[즉, 일반적인 함수는 실행 후 반환(return)될 때까지 빠져나올 수 없고, 빠져나온 후엔 종료되어 재개 할 수 없다. 그러나 코루틴은 반환되기 전에 임의로 중단(yield-return)할 수 있고, 이후에 중단 된 시점에서 재개 할 수 있다.]]

이는 내부적으로 Continuation Passing Style(CPS, 연속 전달 방식)과 State machin을 이용하여 동작한다.
코루틴에서 함수 호출시 연산 결과 및 다음 수행 작업과 같은 제어 정보를 가진 일종의 콜백 함수인 Continuation을 전달하며 각 함수의 작업이 완료되면 Continuation을 호출한다. 이를 통해 상태를 연속적으로 전달하며 컨텍스트를 유지하고 코루틴 실행 관리를 위한 State machin에 따라 코드 블록을 구분해 실행한다.

코루틴은 HTTP 전송, 에셋 로드, 파일 I/O 완료 등을 기다리는 것과 같이 긴 비동기 작업을 처리해야 하는 경우 사용하는 것이 좋다.
다음과 같은 경우도 생각해 볼 수 있다.
- 공격 받은 후 천천히 감소하는 체력바
- 스킬, 아이템의 쿨타임 측정. 그리고 쿨타임 동안 아이콘의 연출(채워진다거나, 비워진다거나)
- 그 외 main 함수와 비동기적으로, 특정 프레임 동안 순차적으로 동작해야 하는 것들.