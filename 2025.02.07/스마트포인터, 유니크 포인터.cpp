스마트 포인터

스마트포인터는 c++의 특별한 클래스 타입으로, 포인터처럼 동작하지만 스스로 메모리를 관리한다.
이는 메모리 누수를 방지하고, 메모리 관리의 복잡성을 줄여준다. 스마트 포인터는 객체가 더 이상 필요하지 않을 때
자동으로 삭제하며, 이러한 기능 때문에 '스마트'라고 부른다. 스마트 포인터의 필요성, 사용 이유, 그리고 작동 
원리에 대해 자세히 알아보도록 하자.

1. 스마트 포인터란?

스마트 포인터(smart pointer)는 C++에서 제공하는 포인터의 한 형태이다.
그러나 일반 포인터와는 다르게 '스마트'한 기능을 가지고 있다. 그렇다면 이 '스마트'한 기능이 뭘까?
바로 자동 메모리 관리이다.

일반적으로 c++에서 동적 메모리를 할당하면 프로그래머는 그 메모리를 직접 해제해야 한다. 이를 잊어버리면 메모리
누수가 발생하게 되고, 이는 프로그램의 성능을 저하시키는 주요한 원인이 된다. 또한 메모리를 해제한 후에 그
메모리를 다시 사용하려고 하는 '잘못된 해제(dangling reference)'문제도 발생할 수 있다. 이런 문제들은
프로그래밍을 복잡하게 만드는 요인 중 하나이다.

이를 해결하기 위해 등장한 것이 스마트 포인터로, 스마트 포인터는 포인터가 가리키는 메모리를 자동으로 해제하는
역할을 한다. 즉, 프로그래머는 메모리 관리에 대해 크게 신경 쓸 필요가 없다.

ex)
#include <memory>

int main()
{
	std::unique_ptr<int> smart_ptr(new int(10));
	return 0;
}

위 예제에서 std::unique_ptr<int>는 int 타입의 스마트 포인터이다.이 스마트 포인터는 new int(10)을 통해
동적으로 할당된 메모리를 가리키고 있다.그러나 가장 중요한 점은 main 함수가 끝나고 samrt_ptr이 사라질 때,
smart_ptr이 가리키는 메모리도 자동으로 해제된다는 것이다.이렇게 해서 프로그래머는 메모리 해제를 신경 쓸
필요가 없게 된다.

스마트 포인터는 이러한 메모리 관리 외에도 소유권(ownership) 개념을 도입하여 자원을 안전하게 공유하거나
이동시키는 데도 사용된다. << --이건 다음에

2. 스마트 포인터의 필요성과 사용이유

스마트 포인터의 필요성과 사용 이유를 이해하려면 먼저 C++의 메모리 관리 체계와 그에 따른 문제점을 이해해야
한다.C++에서는 동적 메모리 할당과 해제를 직접 관리해야 한다.new를 통해 동적으로 메모리를 할당하면 반드시
delete를 통해 그 메모리를 해제해야 한다.

ex)
int* ptr = new int(10); // 메모리 할당
delete ptr; // 메모리 해제

그런데 이런 방식에는 두가지 큰 문제가 있다.

첫번째는 메모리 누수이다.동적으로 할당한 메모리를 해제하기 않고 잊어버리면 그 메모리는 계속 시스템에 할당된
상태로 남게된다.이렇게 되면 메모리 사용량이 증가하고, 결국은 시스테메의 성능을 저하시키는 문제가 발생한다.

두번째 문제는 해제 후 사용(dangling pointer)이다.이미 해제된 메모리를 계속 사용하려는 경우에 발생한다.이는
데이터 손실이나 시스템 충돌을 일으킬 수 있는 심각한 문제이다.

ex)
int* ptr = new int(10);
delete ptr;
*ptr = 20; // 잘못된 해제 후 사용

이처럼 동적 메모리 관리는 프로그래밍의 복잡성을 증가시키고, 실수로 인한 오류 가능성을 높인다.이를 해결하기
위해 등장한 것이 바로 스마트 포인터이다.스마트 포인터는 포인터가 가리키는 메모리를 자동으로 해제해 주기 때문에
위와 같은 문제를 효과적으로 방지 할 수 있다.

ex)
std::unique_ptr<int> smart_ptr(new int(10)); // 메모리 할당
// 메모리 해제는 필요 없음

스마트 포인터를 사용하면 메모리를 직접 관리하는 수고를 덜 수 있다. 또한 메모리 누수나 해제 후 사용과 같은 실수를
예방 할 수 있다. 이러한 이유로, C++에서는 가능한 한 스마트 포인터를 사용하는 것이 권장 된다.

이외에도 스마트 포인터는 메모리 이외의 리소스를 관리 하는 데에도 사용 할 수 있다. 파일, 네트워크 연결, 뮤텍스
등의 리소스를 안전하게 관리하기 위해 스마트 포인터를 사용 할 수 있다.

3. 스마트 포인터의 작동 원리

스마트 포인터는 포인터처럼 동작하지만, 메모리를 직접 관리하는 것이 아니라 RAII(resource Acquistion Is
Inintialization) 이라는 원칙을 사용해 메모리를 자동으로 관리한다. RAII는 객체의 수명이 그 객체가 소유한
자원의 수명과 동일하게 관리되는 것을 의미 한다. 즉, 객체가 생성 될 때 자원을 할당하고, 객체가 소멸 될 때
자원을 해제 한다.

스마트 포인터는 기본적으로 템플릿 클래스로, 포인터와 같은 방식으로 사용 할 수 있다. 그러나 스마트 포인터 객체가
소멸 될 때, 스마트 포인터가 가리키는 메모리를 자동으로 해제한다. 이렇게 해서 프로그래머가 메모리 해제를
잊어 버리는 문제를 예방 할 수 있다.

ex)
std::unique_ptr<int> smart_ptr(new int(10)); // 사믙 포인터 생성
// 스마트 포인터가 소멸되면 메모리는 자동으로 해제된다.

스마트 포인터의 작동 원리를 이해하기 위해서는 C++의 생성자와 소멸자에 대한 이해가 필요하다.생성자는 객체가
생성될 때 호출되고, 소멸자는 객체가 소멸될 떄 호출된다.스마트 포인터의 경우 생성자에서 메모리를 할당하고,
소멸자에서 메모리를 해제한다.

스마트 포인터는 내부적으로 '원시 포인터(raw pointer)'를 보관하고 있다.이 원시 포인터는 스마트 포인터가
가리키는 실제 메모리를 가리킨다.그러나 사용자는 이 원시 포인터에 직접 접근 할 수 없으며, 스마트 포인터가 제공
하는 인터페이스를 통해서만 메모리에 접근 할 수 있다.

ex)
std::unique_ptr<int> smart_ptr(new int(10));
*smart_ptr = 20; // 스마트 포인터를 통해 메모리에 접근

스마트 포인터는 또한 '소유권(ownership)' 개념을 도입하여, 동일한 메모리에 대한 접근을 관리한다.
예를 들어, std::unique_ptr는 이름에서도 할 수 있듯이, 단 하나의 스마트 포인터만이 메모리를 소유 할 수 있다.
이는 메모리 해제를 보다 안전하게 만들어 준다.

스마트 포인터는 이러한 방식으로 메모리 관리의 부담을 줄여준다. 이제 이해 하기 어려웠던 포인터의 개념을 좀 더
쉽게 다룰 수 있게 된다.

스마트 포인터의 종류

C++의 스마트 포인터는 다양한 종류가 있으며, 각각이 메모리 관리를 지원하는 독특한 방식을 가지고 있다.
이번 장에서는 네가지 주요 스마트 포인터 - std::auto_ptr, std::unique_ptr, std::shared_ptr, std::weak_ptr
을 살펴보자. 이중 std::auto_ptr은 C++11 이후로 deprecated(사용이 권장되지 않는)되었으나 이해를 위해
포함시켰다. 나머지 세가지 스마트포인터는 메모리 소유권을 다루는 방식이 서로 다르므로 상황에 맞게 적절히 사용하는
것이 중요하다.

1. std::auto_ptr
std::auto_ptr은 현재 C++11부터 deprecated(사용이 권장되지 않는)상태이며, 이후에 배울 std::unique_ptr이 그 
기능을 대체하게 된다. 하지만 여전히 이해를 돕기 위해 std::auto_ptr에 대해 간략히 설명하고자 한다.

std::quto_ptr은 이름에서도 알 수 있듯이 자동 포인터를 의미한다. 이것은 자동 메모리 관리를 지원하는 첫 번째
스마트 포인터로, 스코프가 끝날 때 자동으로 소멸자를 호출하여 메모리를 해제한다.

ex)
#include <memory>

void auto_ptr_exmple()
{
	std::auto_ptr<int> ptr(new int);
	*ptr = 10;
	std::cout << *ptr << std::_Fnv1a_append_value;
} // 여기서 ptr은 범위를 벗어나 제거된다. 메모리는 자동으로 해제된다.

그러나 std::auto_ptr에는 치명적인 문제가 있다. 그것은 복사 연산을 허용한다는 점으로, 이러한 복사 연산은 동일한
메모리를 가리키는 두 개의 스마트 포인터를 만들 수 있음을 의미하는데, 이는 두 포인터가 동일한 메모리를 해제하려고
할 때 문제를 야기 할 수 있다. 이러한 이유로 std::auto_ptr은 C++11에서 deprecated되었으며, 대신
std::unique_ptr이 도입되었다.

ex)
#include <memory>

void auto_ptr_problem()
{
	std::auto_ptr<int> ptr1(new int);
	*ptr1 = 10;

	std::auto_ptr<int> ptr2 = ptr1; // ptr1이 ptr2에 복사된다.

	std::cout << *ptr2 << std::endl; // 이건 제대로 동작한다.
	std::cout << *ptr1 << std::endl; // 정의되지 않는 동작
}

위의 코드에서 볼 수 있듯이, ptr1이 ptr2로 복사되면서 문제가 발생한다. ptr1은 복사된 후에 null로 설정되며,
ptr2가 이제 동일한 메모리를 가리키게 된다. 이것은 두개의 포인터가 동일한 메모리를 관리하고 있는 상황을 만든다.
이 상황에서 ptr1을 사용하려고 하면 예상하지 못한 동작이 발생하게 된다.

즉, std::auto_ptr은 소유권을 복사하는 대신 이전 소유자에서 새로운 소유자로 이동한다. 이것은 다른 스마트
포인터, 특히 std::unique_ptr에서 볼 수 있는 복사 대신 이동(move)의 아이디어를 반영하는 초기의 시도였다.

이러한 문제점 때문에, std::auto_ptr은 더 이상 사용되지 않으며, 대신 std::unique_ptr 또는 std::shared_ptr는
참조 카운팅을 통해 여러개의 스마트 포인터가 동일한 자원을 안전하게 공유 할 수 있도록 한다.

그래도 std::auto_ptr에 대해 알아두면 스마트 포인터의 작동 원리와 발전 과정을 이해하는데 도움이 될 수 있다. 
이것이 C++의 첫번째 스마트 포인터였고, 후속 버전에서 개선되고 확장된 개념을 제공하므로, 이러한 관점에서
std::auto_ptr을 이해하면 도움이 된다. 그러나 실제 코드에서는 std::auto_ptr대신 std::unique_ptr나
std::shared_ptr을 사용하도록 권장한다.

2. std::unique_ptr

std::unique_ptr은 이름에서 알 수 있듯이, '유일한' 포인터이다. 죽, 동일한 메모리를 가리키는 두개의 
std::unique_ptr인스턴스가 동시에 존재할 수 없다. 이러한 특성은 메모리 누수와 같은 일반적인 문제를 방지하는데
도음이 된다.

ex)

std::unique_ptr<int> ptr1(new int(5));
std::unique_ptr<int> ptr2 = ptr1; //컴파일 에러!

위의 코드에서, ptr1을 ptr2로 복사하려고 했다. 하지만, 이것은 std::unique_ptr의 핵심 원칙에 위반되므로
컴파일러는 이를 허용하지 않는다. 그러나 std::unique_ptr은 '이동' 이라는 개념을 사용하여 포인터의 소유권을 이전
할 수 있다. 이것이 어떻게 작동 하는지 살펴보자.

ex)

std::unique_ptr<int> ptr1(new int(5));
std::unique_ptr<int> ptr2 = std::move(ptr1); // 컴파일 ok

이 경우, std::move 함수를 사용하여 ptr1에서 ptr2로 소유권을 '이동' 시켰다. 이로 인해 ptr1은 이제 null이 되고,
ptr2는 이전에 ptr1이 가리켰던 메모리를 가리키게 된다.

이러한 특성은 std::unique_ptr이 자원의 '유일한' 소유자임을 보장한다. 이것은 메모리 관리를 더욱 안전하고 예측
가능하게 만드는 중요한 속성이다.