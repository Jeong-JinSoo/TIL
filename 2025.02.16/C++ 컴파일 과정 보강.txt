어제는 하지 못한 각 처리 단계의 구체적인 설명들
(추가로, \는 모두 백슬레시로 이해해야 함.)

Phase 1 : 문자들 해석하기

가장 첫번째 단계로 소스 파일에 있는 문자들을 해석한다. 기본적으로 C++ 코드에서는 총 96개의 문자들로 이루어진 Basic source sharacter set이 있는데, 이들은
- 5 종류의 공백 문자들 (스페이스, 탭, 개행 문자 등등
- 10 종류의 숫자들 (0부터 9까지)
- 52 종류의 알파벳 대소문자
- 29 종류의 특수 문자들 ( _ , { , +등등)
으로 구성되어 있다. 이 기본 문자 셋에 포함되어 있지 않은 다른 모든 문자들은 \u 를 통해 유니코드 값으로 치환되거나, 컴파일러에 의해서 따로 해석된다.
 (적어도 GCC의 경우 유니코드를 지원하므로 따로 치환 되는 것은 아닌것 같다.)

Phase 2 : \문자 해석하기

만약에 백슬레시(\) 문자가 문장 맨 끝 부분에 위치 해 있다면, 해당 문장과 바로 다음에 오는 문장이 하나로 합쳐지고 개행 문자는 삭제된다. 쉽게 말해

abc def
 로 된 코드는
abcdef
 로 변경된다.

phase 3 : 전처리 토큰들로 분리하기

이 단계에서는 소스 파일을 주석(comment), 공백 문자, 전처리 토큰(preprocessing token)들로 분리하는 단계이다. 전처리 토큰은 C++에서의 가장 기본적인 문법 요소로, 후에 컴파일러가 사용하는 컴파일러 토큰의 근간이 된다. 아래 해당하는 것들의 전처리 토큰에 포함된다.

- 헤더 이름 ( <iostream>과 같이
- 식별자
- 문자/ 문자열 리터럴
- 연산자들 (+ , ##)

이 단계에서 raw string literal을 확인해서 만일 1~2 단계를 거치면서 해당 문자열 안의 내용이 바뀌었다면 그 변경이 취소된다.

또한 주석은 모두 공백 문자 하나로 변경된다.

참고로, 컴파일러가 전처리기 토큰을 인식할 때에는 가능한 가장 긴 전처리 토큰을 만들려고 한다. 이러한 규칙을 maximal munch 라고 부른다. 예를 들어서

int a = bar+++++baz

라는 문장이 있을 때 우리는 bar ++ + ++baz를 의도한 것이겠지만, maximal munch 규칙에 따라 컴파일러는 가장 긴 전처리 토큰을 구성하려고 하기 때문에 bar++ ++ +baz로 해석되어서 컴파일 오류가 발생한다.

마찬가지로

int bar = 0xE+foo

역시 우리는 0xE + foo를 의도한 것이겠지만 컴파일러의 경우 0xE+ foo로 해석해서 오류가 된다.
그 이유는 부동 소수점 리터럴의 경우 E를 통해서 지수를 지정할 수 있기 때문이다. (0xE + 10과 같은 식으로)

Phase 4 : 전처리기 실행 단계
이제 전처리 토큰들로 분리하였으므로 전처리기를 실행한다. 전처리기가 하는 일들로는 
- #include에 지정된 파일의 내용을 복사한다.
- #define에 정의된 메크로를 사용해서 코드를 치환한다.
- #if, #ifdef와 같은 구문들을 실행해서 코드를 치환한다.
- #pragma와 같은 컴파일 명령문들을 해석한다.

예를 들어서 #include <iostream>을 하였다면 해당 부분은 iostream 헤더파일의 내용으로 치환된다. 실제로 아래와 같이 간단한 프로그램을 살펴보자.

#include <iostream>
int main() {}

실제로 전처리 단계가 끝난 이후의 컴파일러가 보는 소스 파일의 모습은 아래와 같다.

namespace std
{
	typedef long unsigned int size_t;
	typedef long int ptrdeiff_t;
	typedef decltype(nullptr) nullptr_t;
}

namespace std
{
	inline namespace __cxxll __attribute__((__abi_tag__("cxx11"))) {}
}

namespace __gnu_cxx
{
	inline namespace __cxx11 __attribute__((abi_tag__ ("cxx11"))) {}
}

// ...(생략)...
namespace std __attribute__ ((__visibility__ ("default")))
{
	extern istream cin;
	extern ostream cout;
	extern ostream cerr;
	extern ostream clog;
	extern wistream wcin;
	extern wostream wcout;
	extern wostream wcerr;
	extern wostream wclog;
	static ios_base::Init __ioinit;
}

int main() {}
와 같이 생겼다. 그 길이는 무려 27312 줄이다.

전처리 과정이 끝난 후에 파일의 모습을 보고 싶다면 -E 옵션으로 컴파일 하면 된다. 실제로 출력 되는 것은 # 토큰으로 파일에서의 위치를 나타내는 정보가 들어있지만 이들은 컴파일러에 의해 무시된다.

또 다른 예시로 우리는 보통 헤더파일이 여러번 중복되어서 include 되더라도 한 번만 포함이 되게 아래와 같은 헤더 가드(Header guard)를 작성한다.

#ifndef A_H
#define A_H

class A {};
#endif

위와 같은 헤더 가드가 작동하는 이유는 예를 들어서

#include "a.h"
#include "a.h"

을 하더라도 전처리기에 의해서

#ifndef A_H
#define A_H

class A{};
#endif
#ifndef A_H
#define A_H

class A{};
#endif
int main() {}
와 같이 변경되는데, 첫 번째 ifndef에서는 A_H가 정의되어 있지 않기 때문에 사라지지 않지만, 두 번째 ifndef에서는 A_H가 정의되어 있으므로 #ifndef와 #endif사이의 모든 내용들이 개행 문자로 치환된다. 따라서 그냥

class A {};
int main() {}

이렇게 된다.

참고로 #include로 복사된 헤더타일은 다시 phase 1부터 4단계 까지의 과정을 거친다. 이 과정은 소스파일에서 더이상의 전처리문이 없을 때 까지 지속된다.

#참고
간단하게 생각해 봐도 이와 같은 방식은 광징히 비효율적이다. 앞서 본 #include <iostream>을 보함하는 간단한 main 함수만 보아도 우리가 작성한 코드는 단 두줄에 불과 하지만, 실제로 컴파일러가 보는 코드으 길이는 대략 2만 7천 줄에 달하기 때문이다.

이와 같은 문제를 해결하기 위해서 미리 컴파일된 헤더(precompiled header)라는 개념이 도입됐지만, 사용시에는 몇 가지 제약이 있다.

C++20 에서는 모듈(moudule)이라는 개념을 도입해서 이와 같은 문제를 해결할 수 있다. 모듈은 다른 파일의 클래스의 함수들을 참조 할 수 있지만 #include를 할 때 처럼 해당 파일의 모든 내용을 불러오지는 않는다.

Phase 5 : 실행 문자 셋으로 변경하기

모든 문자들은 이전의 소스 코드 문자 셋에서 실행 문자 셋(exution character set)의 문자들로 변경된다. 마찬가지로 이전의 escaped된 자들도 실행 문자 셋의 문자들로 변경된다.

pase 6 : 인접한 문자열 합치기

이 단계에서 인접한 문자열들이 하나로 합쳐진다. 예를 들어서

 std::cout << "abc"
	"def";

의 경우

std::cout << "abcdef";

로 변경된다.
여기까지가 전처리기의 과정이다.

컴파일

전처리기 과정이 끝나고 나면 실제 컴파일 과정이 수행된다. 컴파일 과정에서는 앞서 생성되었던 전처리기 토큰들을 바탕으로 실제 컴파일 토큰을 생성하여 분석하게 된다.

Phase 7 : 해석 유닛 생성 (Translation Unit)

실제로 이 단계에서 우리가 소위 말하는 컴파일이 이루어 진다. 전처리기 토큰들이 컴파일 토큰으로 변환이 되고, 컴파일 토큰들은 컴파일러에 의해 해석되어서 해석 유닛 (Translation Unit)을 생성하게 된다.

Phase 8 : 인스턴스 유닛 생성 (Instantitaion Unit

컴파일러는 생성된 TU를 분석해서 필요로 하는 템플릿 인스턴스들을 확인한다. 템플릿들의 정의 위치가 확인이 되면 해당 템플릿들의 인스턴스화가 진행이 되고 이를 통해서 인스턴스 유닛이 생성된다.

이 단계를 마치게 되면 컴파일러는 비로소 목적 코드를 생성 할 수 있게 된다. 이 목적코드는 마지막 단계인 링킹 단계를 위해서 링커로 전달된다.

링킹

마지막으로 링킹 단계에서는 컴파일러가 생성한 목적 파일들과 외부 라이브러리 파일들을 모아서 실행 파일을 생성한다. 이 링킹 과정이 끝나게 되면, 사용하는 시스템에 따라서 각기 다른 형태의 파일들을 생성하게 된다. 우니도우즈 계열에서 주로 사용하는 실행 파일 형태는 Portable Excutable 이라 불리는 PE 파일 형식의 파일을 생성하게 되고 (우리가 흔히 생각하는 .exe 파일), 리눅스 계열의 시스템의 경우 Executable and Linkable Format, 흔히 ELF라 불리는 형태의  실행 파일을 생성한다.

이 두 실행 파일의 포맷이 다르기 때문에 같은 코드를 컴파일 하더라도 윈도우즈의 PE 실행 파일을 리눅스에서 (일반적으로) 실행할 수 없고, 반대로 윈도우즈에서 리눅스의 ELF 파일을 실행 할 수 없다.