- 저장 방식 지정자 (Storage class specifier)
- 저장 기간 (Storage duration) - automatic, static, thread
- 링크 방식 (Linkage) - internal, external
- 이름 맹글링 (Name Mangling)
- 링킹 (Linking)
- 재배치 (Relocation) - R_X86_64_PC32, R_X86_64_PLT32 등등
- 정적 링킹 (Static linking)
- 동적 링킹 (Dynamic linking)

에 대해서 알아본다.

링킹 과정에서 목적 코드들에 정의된 심볼들 (함수들이나 객체들)의 위치를 확정 시킨다
이 때 C++에서 심볼들의 위치들을 정할 때 어떠한 방식으로 정할지 알려주는 키워드들이 있는데, 이들을 바로 Storage class specifier라고 한다. 번역하자면 '저장 방식 지정자' 정도.

저장 방식 지정자
C++에서 허용 하는 Storage class specifier 들은 아래와 같이 총 4가지가 있다.
- static
- thread_local
- extern
- mutable (저장 기간과 링크 방식에 영향을 주진 않는다.)

이전에는 auto와 register 지정자들도 있었는데 이들은 각각 C++ 11과 C++ 17에서 사라졌다. 이 키워드들을 통해 심볼들의 두 다지 중요한 정보들을 지정 할 수 있다. 바로 저장 기간 (Storage duration)과 링크 방식 (Linkage)이다. 각각이 무엇인지 아래에서 살펴본다.

저장 기간 (Storage duration)

프로그램에서의 모든 객체들의 경우 반드시 아래 넷 중에 한 가지 방식의 저장 기간을 가지게 된다.

자동 (automatic) 저장 기간

여기에 해당 하는 객체의 경우 보통 {} 안에 정의된 녀석들로 코드 블록을 빠져나가게 되면 자동으로 소멸 하게 된다. static, extern, thread_local로 지정된 객체들 이외의 모든 지역 객체들이 바로 이 자동 저장 기간을 가지게 된다. 쉽게 말해 우리가 흔히 생각하는 지역변수들이 여기에 해당된다.

int func() {
  int a;
  SomeObject x;

  {
    std::string s;
  }

  static int not_automatic;
}

위 경우 a, x, s 모두 자동 저장 기간을 가진다. 반면에 not_automatic은 아니다.

static 저장기간

static 저장기간에 해당하는 객체들의 경우 프로그램이 시작 할 때 할당되고, 프로그램이 끝날 때 소멸 되는 친구들이다. 그리고 static객체들은 프로그램에서 유일하게 존재한다. 예를 들어서 지역변수의 경우 만일 여러 쓰레드에서 같은 함수를 실행한다면 같은 지역 변수의 복사본들이 여러 군데 존재하겠지만 static 객체들은 이 경우에도 유일하게 존재한다.

보통 함수 밖에 정의된 것들이나 (즉 namespace 단위에서 정의된 것들) static 혹은 extern으로 정의된 객체들이 static 저장 기간을 가진다. 참고로 static 키워드와 static 저장 기간을 가진다는 것을 구분해야 한다. static 키워드가 붙은 객체들이 static 저장 기간을 가지는 것은 맞지만, 다른 방식으로 정의 된 것들도 static 저장 기간을 가질 수 있다.

예를 들어서

int a;  // 전역 변수 static 저장 기간
namespace ss {
int b;  // static 저장 기간
}

extern int a;  // static 저장 기간
int func() {
  static int x;  // static 저장 기간
}

위와 같이 여러가지 방식으로 정의 된 객체들이 static 저장 기간을 가지게 된다.

쓰레드(thread) 저장기간

쓰레드 저장 기간에 해당하는 객체들의 경우 쓰레드가 시작 할 때 할당되고, 쓰레드가 종료될 때 소멸 되는 객체들 이다. 각 쓰레드들이 해당하는 객체들의 복사본들을 가지게 된다. thread_local로 선언된 객체들이 이 쓰레드 저장 기간을 가질 수 있다.

#include <iostream>
#include <thread>

thread_local int i = 0;

void g() { std::cout << i; }

void threadFunc(int init) {
  i = init;
  g();
}

int main() {
  std::thread t1(threadFunc, 1);
  std::thread t2(threadFunc, 2);
  std::thread t3(threadFunc, 3);

  t1.join();
  t2.join();
  t3.join();

  std::cout << i;
}

예를 들어서 위 예제를 살펴보자. 아마 몇번 실행하다 보면 1230, 2130, 3120등과 같은 결과를 볼 수 있다. 그 이유는 thread_local로 정의된 i가 각 쓰레드에 유일하게 존재하기 때문이다. 마치 정의는 전역 변수인것 처럼 정의되어 있지만, 실제로는 각 쓰레드에 하나씩 복사본이 존재하게 되고, 각 쓰레드 안에서 해당 i를 전역 변수인것마냥 참조 할 수 있게 된다.

동적 (Dynamic) 저장 기간
동적 저장 기간의 경우 동적 할당 함수를 통해서 할당 되고 해제되는 객체들을 의미한다. 대표적으로 new와 delete로 정의되는 객체들을 의미한다.

이러한 저장 방식은 나중에 링커에서 해당 변수나 함수들을 배치시에 어디에 배치 할 지 중요한 정보로 사용된다.

링크 방식 (Linkage)
앞선 저장 방식이 객체 들 에게만 해당되는 내용이었다면 링크 방식의 경우 C++의 모든 객체, 함수, 클래스, 템플릿, 이름 공간 등등을 지칭하는 이름들에 적용되는 내용이다. C++에선 아래와 같은 링크 방식들을 제공한다. 이 링크 방식에 따라서 어떤 이름이 어디에서 사용 될 수 있는지 지정 할 수 있다.

링크 방식 없음 (no linkage)

블록 스코프 {} 안에 정의되어 있는 이름들이 이 경우 해당한다. (extern으로 지정되지 않는 이상)링크 방식이 지정 되지 않는 객체들의 경우에는 같은 스코프 안에서만 참조 할 수 있다.

예를 들어서

 { int a = 3; }
a;  // 오류

위 경우 a라는 변수는 {} 안에 링크 방식이 없는 상태로 정의되어 있기 때문에 스코프 바깥에서 a를 참조 할 수 없게 된다.

Internal Linkage

static으로 정의된 함수, 변수, 템플릿 변수들이 내부 링크 방식에 해당된다. 내부 링크 방식으로 정의된 것들의 경우 같은 TU 안에서만 참조 할 수 있다. 그 외에도 익명의 이름 공간에 정의된 함수나 변수들을 모두 내부 링크 방식이 적용된다.

namespace {
int a;  // <- 내부 링크 방식
}
static int a;  // 이와 동일한 의미

외부 링크 방식 (external Linkage)

마지막으로 살펴볼 방식은로 외부 링크 방시이 있다. 외부 링크 방식으로 정의된 개체들은 다른 TU에서도 참조 가능하다. 참고로 외부 링크 방식으로 정의 된 개체들에 언러링크 방식을 정의 할 수 있어서, 다른 언어( C와 C++)사이에서 함수를 공유하는 것이 가능해진다.

앞서 링크 방식이 없는 경우나 내부 링크 방식을 개체들을 정의하는 경우를 제외하면 나머지 모두 외부 링크 방식으로 정의됨을 할 수 있다. 참고로, 블록 스코프 안에 정의된 변수를 외부링크 방식으로 선언하고 싶다면 extern 키워드를 사용하면 된다.

언어 링크 방식을 선언하려면 다음과 같이 하면 된다.

extern "C" int func();  // C 및 C++ 에서 사용할 수 있는 함수.

// C++ 에서만 사용할 수 있는 함수. 기본적으로 C++ 의 모든 함수들에 extern "C++"
// 이 숨어 있다고 보시면 됩니다. 따라서 아래처럼 굳이 명시해줄 필요가 없습니다.
extern "C++" int func2();
int func2();  // 위와 동일

이름 맹글링 (Name Mangling)
앞서 C에서 C++의 함수를 사용하기 위해서는 extern "C"로 언어 링크 방식을 명시해주어야 한다. 그 이유는, 목적 파일 생성시 C 컴파일러가 함수 이름을 변환하는 방식과 C++ 컴파일러가 함수 이름을 변환하는 방식이 다르기 때문이다.

일단 C의 경우 함수 이름 변환 자체가 이루어 지지 않는다. 만약에 아래와 같이 func이란 함수를 정의했다고 해보자.

int func(const char* s) {}
이를 C 컴파일러가 컴파일 하면 변환된 이름은 그냥

$ nm a.out
0000000000000000 T func
func 임을 알 수 있다. 참고로 nm 은 목적 파일에 정의되어 있는 심볼들을 모두 출력해주는 프로그램이다.

반면에 똑같은 소스코드를 C++컴파일러로 컴파일 해보자.

$ nm a.out
0000000000000000 T _Z4funcPKc

위 경우 함수의 이름이 바뀐 것을 알 수 있다. 이와 같이 C++에서는 같은 이름의 함수를 정의 할 수 있기 때문이다. 일단 함수의 오버로딩을 통해서 인자가 다른 같은 이름의 함수들을 정의 할 수 있고 인자와 이름이 모두 똑같더라도 다른 이름 공간에 들어가 있다면 다른 함수로 취급된다. 따라서, 함수의 이름 자체만으로는 어떤 함수를 호출 할 지 구분 할 수 없다.

이름 맹글링을 하게 되면 원래의 함수 이름에 이름 공간 정보와 함수의 인자 타입 정보들이 추가 된다. 따라서 같은 이름의 함수일 지라도, 이름 맹글링을 거치고 나면 다른 이름의 함수로 바뀌기 때문에 링킹을 성공적으로 수행 할 수 있다.

실제로 함수들의 이름들은 모두 같지만

int func(const char* s) {}
int func(int i) {}
int func(char c) {}

namespace n {
int func(const char* s) {}
int func(int i) {}
int func(char c) {}
}  // namespace n

맹글링 된 이름을 살펴보면

$ nm test.o
000000000000001d T _Z4funcc
000000000000000f T _Z4funci
0000000000000000 T _Z4funcPKc
000000000000004a T _ZN1n4funcEc
000000000000003c T _ZN1n4funcEi
000000000000002d T _ZN1n4funcEPKc

와 같이 전부 다른 이름으로 변환 된 것을 볼 수 있다. 참고로 컴파일러마다 이름을 맹글링을 하는 방식이 조금씩 다르기 때문에 A라는 컴파일러에서 생성한 목적 코드를 B 컴파일러가 링킹할 때 문제가 될 수 있다.

아무튼 C에서 C++ 함수를 호출하기 위해서는 반드시 이름 뱅글링이 되지 않는 함수 심볼을 생성해야 한다. 따라서 extern "C"를 통해서 이 함수는 이름 맹들링을 하지마! 라고 컴파일러에게 전달 할 수 있다.

extern "C" int func(const char* s) {}
int func(char c) {}

위 코드를 컴파일 하면

$ nm test.o
0000000000000000 T func
000000000000000f T _Z4funcc

위와 같이 extern "C"로 표기된 func은 이름 맹글링이 되지 않았지만 밑에 보통의 int func의 경우 이름 맹글링이 된 것을 알 수 있다.

당연히도 extern "C"가 붙은 함수들 끼리는 오버로딩을할 수 업다. 왜냐면 심볼 생성시 두 함수를 구분 할 수 있는 방법이 없기 때문이다. (이름이 같으니까)

링킹
위 단계에서 아무런 문제가 없었더라면 이제 비로소 진짜(Linking)을 수행할 수 있다.
링킹이란, 각 TU들에서 생성된 목적코드들을 한데 모아서 하나의 실행파일을 만들어 내는 작업이다. 물론 단순히 목적 코그를 이어 붙이는 작업만 하는 것은 아니다.

링킹 과정이 끝나기 전 까지 변수들과 함수, 그리고 데이터들의 위치를 확정 시킬 수 없다. 따라서 TU들이 생성한 목적 코드들에게는 각각의 심볼들의 저장 방식과 링크 방식에 따라서 여기 여기에 배치 했으면 좋겠다 라는 희망 사항만 써져 있을 뿐이다.

static int a = 3;
int b = 3;
const int c = 3;
static int d;

int func() {}
static int func2() {}

위와 같은 코드를 생각 해보자.
위 코드에 정의된 심볼들의 희망 위치들은 어떻게 나타날까?

$ nm test.o
0000000000000004 D b
0000000000000000 T _Z4funcv
0000000000000000 d _ZL1a
0000000000000000 r _ZL1c
0000000000000000 b _ZL1d
000000000000000b t _ZL5func2v

nm 프로그램은 심볼들의 이름들 왼쪽에 어떠한 방식으로 링크시에 심볼을 배치할지에 대한 정보를 보여준다. 먼저 가운데 알파벳을 보자. 대문자 알파벳의 경우 해당 심볼은 외부 링크 방식으로 선언된 심볼이란 의미이다. 즉, 해당 심볼은 다른 TU에서 접근 할 수 있는 심볼이다. 반면에 소문자 알파벳의 경우 해당 심볼은 내부 링크 방식으로 선언된 심볼이란 의미이다. 따라서 해당 심볼은 이 TU 안에서만 접근 가능하다.

위 대문자로 된 심볼들을 보면 b, func를 볼 수 있는데 두 함수 다 외부 링크 방식임을 알 수 있다. 반면에 나머지 a, c, d, func2는 모두 static이므로 내부링크 방식이다.

그 다음에 알파벳 자체는 어떠한 방식으로 해당 심볼들을 배치할 지 알려준다.
일부만 잠깐 알아보자면

B , b : 초기화 되지 않은 데이터 섹션 (BSS 섹션)
D, d : 초기화 된 데이터 섹션
T, t : 텍스트 (코드) 섹션
R, r : 일기 전용 (read only) 섹션

이다. 예를 들어 전역 변수인 b를 보자.

0000000000000004 D b

b는 값을 3으로 초기화 하였으므로 당연히 초기화 된 데이터 섹션에 가게 된다.
반면에 static int d의 경우

0000000000000000 b _ZL1d

값을 초기화 하지 않았으므로 초기화 되지 않은 데이터 셋션인 BSS로 지정되어 있음을 알 수 있다.

0000000000000000 T _Z4funcv // func()
000000000000000b t _ZL5func2v // func2()

마찬가지로 두개의 함수들만 보아도 static이 아닌 func는 T, satatic인 func2는 t로 표시되어 있음을 알 수 있다.

맨 앞에 오는 정수값은 섹션의 시작 부분에 있다는 의미 이고 (오프셋은 0 이니까), func2의 경우 b 만큼 떨어진 부분에 위치해 있다는 의미이다. 실제로 objdump로 코드를 보면

objdump -S s.o 

s.o:     file format elf64-x86-64


Disassembly of section .text:

0000000000000000 <_Z4funcv>:
   0:	f3 0f 1e fa          	endbr64 
   4:	55                   	push   %rbp
   5:	48 89 e5             	mov    %rsp,%rbp
   8:	90                   	nop
   9:	5d                   	pop    %rbp
   a:	c3                   	retq   

000000000000000b <_ZL5func2v>:
   b:	f3 0f 1e fa          	endbr64 
   f:	55                   	push   %rbp
  10:	48 89 e5             	mov    %rsp,%rbp
  13:	90                   	nop
  14:	5d                   	pop    %rbp
  15:	c3                   	retq   

정확히 0xb 부분에 func2가 자리하고 있음을 알 수 있다.