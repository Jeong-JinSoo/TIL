typedef 예약어

typedef 예약어는 저장소 클래스 지정자 중 하나이다.
typedefine은 type define의 약자로 해석하면 "형식을 정의해"라는 뜻이 있다.
기존의 자료형에 새롭게 별칭을 부여할 때 사용한다.

typedef 기존type 별칭;

typedef를 이용하면 구조체, 공용체, 열거형도 조금 더 간단하게 사용할 수 있다.
예제를 통해 보자.

#include <stdio.h>

typedef struct student{
	char name[20];
    int age;
	char address[30];
}STUDENT;  //새로운 STUDENT 키워드를 부여

int main(void) {

	STUDENT stu;
	stu.age = 20;
	printf("나이는  = %ㅇ \n", stu.age);
	return 0;
}

struct 앞에 typedef를 선언하고 정의 뒤에 새로운 별칭을 추가로 선언해주면 구조체 변수를 선언 할 때 struct를 붙이지 않아도 선언해서 사용 할 수 있다.

union과 enum도 마찬가지로 가능하다.

함수 정의도 typedef를 이용해서 간단하게 할 수 있다.

#include <stdio.h>
#include <string.h>

typedef struct student
{
	char name[20]
	int age;
	char address[30]
} STUDENT;

STUDENT studentInfo(char* _name, int _age, char* _address)
{
	STUDENT stu;
	strcpy (stu.name, _name);
	stu.age = _age;
	stucpy (stu.address, _address);
	return stu;
}

int main(void
{
	STUDENT stu = studentInfo ( "철수", 20, "서울시" );
	printf ("이름 = %s \n", stu.name);
	printf ("나이 = %d \n", stu.age);
	printf ("주소 = %s \n", stu.address);
	return 0;
}

sturct 구조체이름을 반환형으로 선언하지 않고 그냥 별칭만으로 함수를 선언할 수 있다.
 typedef를 이용해서 일반 자료형이나 배열들도 간편하게 선언할 수 있다.

#include <stdio.h>

typedef unsigned int unit;
typedef int int_array [10];

int main(void)
{
	unit num;
	num = 10;
	int_array num2 = { 1,2,3,4,5,6,7,8,9,0};
}

unsigned int를 typedef를 이용해서 unit라는 별칭을 부여한다.
그러면 unit로 선언된 변수들은 unsigned int의 자료형으로 선언된거와 같게 된다.
typedef를 이용해 int형 크기 10의 배열을 선언해서 별칭으로 변수를 선언하면 변수는 int[10]의 크기를 가지게 된다. typedef를 이용하면 사용 용도나 긴 자료형을 간단하게 표현하여 효율을 높일 수 있다.

decltype

decltype 키워드는 C++11에 추가된 키워드로, decletype라는 이름의 함수처럼 사용된다.

decltype(/* 타입을 알고자 하는 식 */)

이 때, deltype은 함수와는 달리, 타입을 알고자 하는 식의 타입으로 치환되게 된다.

#include <iostream>

struct A {
  double d;
};

int main() {
  int a = 3;
  decltype(a) b = 2;  // int

  int& r_a = a;
  decltype(r_a) r_b = b;  // int&

  int&& x = 3;
  decltype(x) y = 2;  // int&&

  A* aa;
  decltype(aa->d) dd = 0.1;  // double
}

위 코드의 경우 deltype이 각각 int, int&, int&&로 치환되서 컴파일 되게 된다. 위와 같이 decltype에 전달된 식이 괄호로 둘러 쌓이지 않은 식별자 표현식(id-expression) 이라면 해당 식의 타임을 얻을 수 있다.

참고로 식별자 표현식이란 변수의 이름, 함수의 이름, enum 이름, 클래스 멤버 변수(a.b나 a->b같은 꼴)등을 의미한다. 쉽게 생각하면 어떠한 연산을 하지 않고 단순히 객체 하나만을 가리키는 식이라고 볼 수 있다.

그렇다면 만약에 decltype에 식별자 표현식이 아닌 식을 전달하면 어떻게 될까? 그렇다면 해당 식의 값의 종류(value category)에 따라 달라진다.

만일 식의 값 종류가 xvalue 라면 decltype 는 T&& 가 된다.

만일 식의 값 종류가 lvalue 라면 decltype 는 T& 가 된다.

만일 식의 값 종류가 prvalue 라면 decltype 는 T 가 된다.

여기서 값의 종류? xvalue? lvalue? prvalue? 라는 개념이 나왔다. 이건 뭘까?