가상 함수(virtual function)

C++에서 가상 함수(virtual function)는 파생 클래스에서 재정의 할 것으로 기대하는 멤버 함수를 의미한다.
이러한 가상 함수는 자신을 호출하는 객체의 동적 타입에 따라 실제 호출할 함수가 결정된다.

C++에서 가상 함수는 virtual 키워드를 사용하여 선언한다. 기초 클래스에서 virtual 키워드를 사용해 가상 함수를 선언하면, 파생 클래스에서 재정의 된 멤버 함수도 자동으로 가상함수가 된다.

동적 바인딩(dynamic binding)
C++ 컴파일러는 함수를 호출 할 때, 어느 블록에 있는 함수를 호출해야 하고, 해당 함수가 저장된 정확한 메모리 위치까지도 알아야 한다. 이처럼 함수를 호출하는 코드에서 어느 블록에 있는 함수를 실행하라는 의미로 해석하는 것을 바인딩이라고 한다.
하지만 C++에서는 함수가 오버로딩 될 수 있으므로 이 작업이 조금 복잡해진다.

대부분 함수를 호출하는 코드는 컴파일 타임에 고정된 메모리 주소로 변환된다.
이것을 정적 바인딩(static binding) 이라고 한다. C++에서는 가상 함수가 아닌 멤버 함수는 모두 이러한 정적 바인딩을 하게 된다.

하지만 가상 함수의 호출은 컴파일러가 어떤 함수를 호출해야 하는지 미리 알 수 없다. 왜냐하면, 가상함수는 프로그램이 실행될 때 객체를 결정하므로, 컴파일 타임에 해당 객체를 특정 할 수 없기 때문이다. 따라서 가상 함수의 경우에는 런타임에 올바른 함수가 실행 될 수 있도록 해야 한다.

이것을 동적 바인딩(dunamic binding)또는 지연 바인딩(late binding)이라고 한다.

하지만 가상 함수도 결합하는 타입이 분명할 때에는 일반 함수와 같이 정적 바인딩을 한다.
이러한 가상 함수는 기초 클래스 타입의 포인터나 참조를 통하여 호출 될 때만 동적 바인딩을 하게 된다.

가상 함수 테이블(virtual function table, vtbl)
C++에서는 가상 함수의 정의와 동작 방식만을 규정하고 있으며, 그에 따른 구현은 컴파일러마다 다르다. 하지만 컴파일러가 가상 함수를 다루는 가장 일반적인 방식은 가상 함수 테이블 (virtual function table)을 이용하는 것이다.

C++ 컴파일러는 각각의 객체바다 가상 함수 테이블을 가리키는 포인터를 저장하기 위한 숨겨진 멤버를 하나씩 추가한다. 이와 함께 가상 함수를 단 하나라도 가지는 클래스에 대해서 가상 함수 테이블을 작성한다. 
이렇게 작성된 가상 함수 테이블에는 해당 클래스의 객체들을 위해 선언된 가상 함수들의 주소가 저장되게 된다.

가상 함수를 호출하면, C++ 프로그램은 가상 함수 테이블에 접근하여 자신이 필요한 함수의 주소를 찾아 호출하게 된다. 가상함수를 사용하면 이 처럼 함수의 호출과정이 복잡해지므로, 메모리와 실행 속도 측면에서 약간의 부담을 가지게 된다. 따라서 C++에서 기본 바인딩은 정적 바인딩이며, 필요한 경우에만 가상 함수로 선언하도록 하고 있다.

가상 소멸자
C++에서 자식 클래스의 소멸자는 반드시 가상으로 선언해야 한다.
클래스가 소멸 할때, 마지막 소멸자는 자신의 소멸자가 아닌 부모의 소멸자를 호출하게 된다. 그러므로 자신에게 할당된 메모리는 정상적으로 해제되지 않는 문제가 생긴다.

하지만 자신의 클래스 소멸자를 가상으로 선언한다면, 정상적으로 자신의 소멸자를 호출하게 된다. 따라서 자식 클래스는 명시적으로 소멸자를 선언할 필요가 없더라도, 아무일도 하지 않는 가상 소멸자를 호출해야 한다.