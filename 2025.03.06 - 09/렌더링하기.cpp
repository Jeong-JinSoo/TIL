프레임 렌더링

Direct3D 초기화가 끝나면 실제 렌더링을 시작할 차례이다. 렌더링 자체는 매우 쉽지만 약간의 준비 작업이 필요하다. 이 수
업에서는 빈 프레임을 계속해서 렌더링 하기 위한 모든 것을 설정한다.

관련된 설정은 간단하다.해야 할 일이 두 가지 있다.첫째, GPU에 최종 이미지를 만들 메모리의 어느 부분을 알려야 한다.(이
경우 백버퍼를 말한다.) 들째, GPU에 백 버퍼의 어느 부분에 그려야 하는지 알려야 한다.

그 작업이 끝나면 렌더링을 시작 할 수 있다.

렌더 타겟 설정

렌더링 할 위치부터 시작해본다. 당연히 백버퍼이지만, 이 시점에서 Direct3D은 이 지섬에서 실제로 그것을 알지 못한다. 백
버퍼에 바로 렌더링 하고 싶지 않을 수도 있다. 예를 들어 많은 게임이 모델 표면에 렌더링 한 다음 해당 모델을 백 버처에 렌
더링 할 수도 있다.이 기술은 다양한 효과를 낼 수 있다. Portal이 대표적인 예시인데, 먼더 포털에 렌더링 한 다음 포탈 이
미지가 전체장면을 렌더링 한다.

Direct3D에서는 렌더링 할 때 렌더타겟을 설정해야 한다. 이것은 비디오 메모리에서 렌더링 할 위치를 유지하는 간단한 COM 객
체이다. 대부분의 경우 이것은 백 버퍼 이다.

우리가 이를 수행하는 방법은 다음과 같다.

ID3D11RenderTargetView* backbuffer; // 전역 선언

// 이 함수는 Direct3D를 초기화하고 사용할 수 있도록 준비합니다 
void InitD3D(HWND hWnd)
{
	// Direct3D 초기화 
	// ... 

	// 백 버퍼의 주소를 가져옵니다 
	ID3D11Texture2D* pBackBuffer;
	swapchain->GetBuffer(0, __uuidof(ID3D11Texture2D), (LPVOID*)&pBackBuffer);

	// 백 버퍼 주소를 사용하여 렌더 타겟을 생성합니다 
	dev->CreateRenderTargetView(pBackBuffer, NULL, &backbuffer);
	pBackBuffer->Release();

	// 렌더 타겟을 백 버퍼로 설정합니다 
	devcon->OMSetRenderTargets(1, &backbuffer, NULL);
}

여기서는 세가지가 수행된다.
첫째, 백 버퍼의 주소를 결정한다.
둘째, 해당 주소를 사용하여 렌더 타겟을 나타내는 COM 객체를 만든다.
셋째, 해당 객체를 활성 렌더 타겟으로 설정한다.

여기에 추가된 새로운 코드들이 무슨 뜻인지 알아보자.

ID3D11RenderTargetView* backbuffer;
	이 변수는 렌더 타겟에 대한 모든 정보를 보관하는 객체에 대한 포인터이다. 우리는 백 버퍼에 렌더링 할 것이므로 이
	변수를 'backbuffer'라고 부른다.

ID3D11Texture2D *pBackBuffer;
	3D 렌더링에서 텍스처는 이미지의 다른 이름입니다. ID3D11Texture2D는 플랫 이미지를 저장하는 객체이다. 모든 COM 객
	체와 마찬가지로 먼저 포인터를 정의하고 나중에 함수가 객체를 생성한다.

swapchain->GetBuffer(0, __uuidof(ID3D11Texture2D), (LPVOID*)&pBackBuffer);
	이건 간단하다. 이 GetBuffer() 함수가 하는 일은 스왑체인에서 백 버퍼를 찾아서 pBackBuffer 텍스처 객체를 만드는 것
	이다.

	첫 번째 배개변수는 가져올 백 버퍼의 번호이다. 이 체인에서 백 버퍼 하나만 사용하고 있으며, 백버퍼 #0이다. 따라
	서 매개변수는 0이 된다. 

	두 번째 매개변수는 ID3D11Texture2D COM 객체를 식별하는 숫자이다. 각 유형의 COM 객체에는 고유한 ID가 있으며, 이를
	사용하여 해당 객체에 대한 정보를 얻는다. 이 ID를 얻으려면 __uuidof 연산자를 사용해야 한다. 이것이 어떻게 작동하는
	지에 대한 정확한 세부 사항은 지금 중요하지 않지만, 우리가 이렇게 하는 이유는 GetBuffer() 함수가 어떤 유형의 객체를
	만들어야 하는지 알 수 있도록 하기 위해서이다.

	세 번째 매개변수에는 void*에 대한 포인터가 있다. 이 void*는 ID3D11Texture2D객체의 위치로 채워진다. void*여야 하는데,
	우리가 요청 할 수 있는 다른 유형의 객체가 있기 때문이다.

	이 특정 기능은 지금 당장은 너무 많이 건드리지 않는다. 

dev->CreateRenderTargetView(pBackBuffer, NULL, &backbuffer);
	이 함수는 렌더 타겟 객체를 생성한다. 우리는 프로그램 맨 위에 이 객체에 대한 포인터를 생성했다.

	첫 번째 매개변수는 텍스처에 대한 포인터이다. 우리 프로그램의 경우 'pBackBuffer'여야 한다.

	두 번째 매개변수는 렌더 타겟을 설명하는 구조체이다. 백 버퍼에 대해서는 이것을 채울 필요가 없다. 그냥 NULL로 설정
	한다.

	세 번째 매개변수는 객체 포인터의 주소이다. 포인터의 이름은 'backbuffer' 였으므로 '&backbuffer'를 사용한다.

pBackBuffer->Release();
	Release() 함수는 모든 메모리를 해제하고 COM객체에서 새용하는 모든 스레드를 닫는다.
	pBackbuffer 객체에 대한 작업이 끝났으므로 Release()를 실행한다. 이렇게 하면 백버퍼가 파괴되지 않고, 엑세스 하는
	데 사용한 텍스처 객체만 닫힌다.

devcon->OMSetRenderTargets(1, &backbuffer, NULL);
	이 마지막 함수는 실제로 렌더 타겟을 설정한다. 더 정확히 말하면, 여러 렌더 타겟을 설정한다.

	첫 번째 매개변수는 설정할 렌더 타겟의 수 이다. 이는 일반적으로 1이지만 더 많은 경우가 있다.

	두 번째 매개변수는 렌더 타겟 뷰 객체 목록을 가리키는 포인터이다. 우리는 하나만 가지고 있으므로, 그것은 단지 우리의
	렌더 타겟 객체(&backbuffer)의 주소일 뿐이다.

	세 번째 매개변수는 고급이며, 이것은 나중에 다룬다 지금은 NULL로 둔다.

	이 다음은 조금 복잡하다. 무슨 일이 일어나는지 이해 할 때 까지 반복해서 보는 것이 좋다. Direct3D 프로그래밍에서 여
	러번 사용되고 수정되기 때문이다.

뷰포트 설정