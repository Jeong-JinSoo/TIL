#include <iostream>
using namespace std;

//C++
//참조자 //포인터와 다르게 변하지 않는 주소 //또하나의 이름

//참조변수 선언 //포인터와 참조 비교하기 ---------------------------------------

int main(void)
{
	int a = 0;			// int a
	int* p = &a;		// int* p	//주소를 담는 또다른 변수		//C
	*p = 2;				

	int b = 0;			// int b, r		
	int& r = b;			// r 은 b 로 해석됨. 또 하나의 이름		//C++
	r = 2;

	p = nullptr;		//포인터는 참조하는 주소 변경 가능하다.
	r = a;				//참조의 경우는 참조대상이 있어야 하고, 변하지 않음.
}

//참조변수 선언 //사용, 주소 비교하기 ------------------------------------------

int main(void)
{
	int num1 = 1024;
	int& num2 = num1;			//참조변수 선언	//별명, 또하나의 이름

	num2 = 2000;				//num2로 하는 모든 연산은 num1로 하는것과 동일
	cout << num1 << endl;
	cout << num2 << endl;

	cout << &num1 << endl;		//주소 비교하기
	cout << &num2 << endl;

	//참조자의 수에는 제한이 없으며, 참조자를 대상으로 참조자를 선언하는 것도 가능
	int& num3 = num2;
	int& num4 = num3;

	//일단 초기화되면 참조를 재할당할 수 없다. ***  ------------------
	//	참조는 변경되는 것이 아니므로 포인터보다 안전하게 사용이 가능하다. 

	num3 = num4;				//참조가 변경되는 것이 아니다. num3 에 num4의 값을 대입하는 것이다.

	//참조 대상이 있어야 한다. *** ----------------------------------
	int& ref;					//error
	int& ref = NULL;			//error		//포인터와 다르게, null 참조 같은 것은 없다.
	int& ref = 10;				//error		//10은 상수 주소가 없다.
}

//변수 타입에 대해 선언이다.-----------------------------------------------------

int main(void)
{
	//배열인자도 변수 성향이므로 참조자 가능 ---------------------
	int arr[3] = { 1, 3, 5 };
	int& ref1 = arr[0];
	int& ref2 = arr[1];
	cout << ref1 << endl;
	cout << ref2 << endl;

	//포인터도 변수이므로 참조자 가능 ---------------------------
	int num = 12;
	int* ptr = &num;

	int& ref = num;
	int*& pref = ptr;		//포인터 ptr 에 대한 참조 선언 
	//int* (&pref) = ptr;

	cout << ref << endl;
	cout << *pref << endl;	//pref는 포인터를 참조하므로 포인터.

	//참조자를 포인터 포인터로 가르키는 것도 가능 --------------------------
	int* rptr = &ref;		//&ref == &num
	cout << *rptr << endl;

	return 0;
}

//컴파일러는 참조자를 메모리에 할당하지 않고, 참조자가 참조하는 변수의 alias처럼 생각한다.
//예를 들어  int& b = a; 경우, 컴파일러는 b가 나오면 그냥 다 a로 생각하는 것이다.

// 포인터의 경우, nullptr 인지 여부를 확인하고 사용해야 한다. 또 변경될 때 주의해야 한다.
// 참조 사용의 경우, 참조하는 대상이 존재하는지 여부를 주의해야 한다. ***