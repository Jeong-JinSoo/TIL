//포인터에 대한 레퍼런스 //이중포인터
// 
//		레퍼런스는 또다른 이름, 포인터 변수에 대한 또다른 이름
//		이중포인터처럼, 레퍼런스 포인터의 값과 레퍼런스 포인터가 가르키는 값을 변경할수 있다.

#include <iostream>
using namespace std;

int main(void)
{
	int*& a;				//선언시 사용 // 포인터의 레퍼런스
	int b = 1;
	cout << *&b << endl;	//*&b == b	//주소의 역참조 
	return 0;
}

//------------------------------------------
void Test(int*& a, int* b)
{
	a = b;
}

int main(void)
{
	int a = 1;
	int b = 2;
	int* pa = &a;
	int* pb = &b;

	Test(pa, pb);

	cout << *pa << endl;
	cout << *pb << endl;
}

// 참조형 타입의 장점은 메모리의 소유가 어디인지를 명확히 하는데 있다.
//		참조로 함수에 넘기게 되면, 해제 할수가 없다.
//		포인터를 이용하다가 엉뚱한 메모리를 수정하는 불상사를 미연에 방지
//		참조는 포인터에 비해 유연하지는 않지만 안정성을 보장해 준다.

// 가능하면 참조자를 쓰고, 어쩔 수 없다면 포인터를 써라 ***
// 매개변수에 NULL 포인터를 넘겨주는 것 or 리턴값으로 NULL 포인터를 반환하는 것이 허용될 경우, 포인터를 사용해야 한다.

// 포인터의 경우 nullptr 인지 여부를 확인하고 사용해야 한다. ***
// 참조 사용의 경우, 참조하는 대상이 존재하는지 여부를 주의해야 한다. ***

